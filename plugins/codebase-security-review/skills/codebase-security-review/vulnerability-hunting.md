# Phases 4-5: Vulnerability Hunting & Deep Dive

Phase 4 systematically hunts for vulnerabilities using the OWASP Top 10 as a framework. Phase 5 deep-dives on HIGH/CRITICAL findings to build exploit scenarios.

Both phases rely heavily on the context built in Phases 1-3 (Reconnaissance → Deep Context → Threat Model). Do NOT skip to this file without completing earlier phases.

---

## Phase 4: OWASP-Guided Vulnerability Hunting

For each OWASP category: understand what to look for, run detection patterns, review matches manually, and record findings.

### A01: Broken Access Control

**What to check:**
- Missing function-level authorization (endpoint accessible without proper role)
- Insecure Direct Object References (IDOR) — user-supplied IDs used to fetch resources without ownership check
- CORS misconfiguration (wildcard origins with credentials)
- Directory traversal (user-controlled paths joined without sanitization)
- Missing deny-by-default (new endpoints auto-accessible)

**Detection patterns:**
```bash
# IDOR candidates: user-supplied IDs used in queries
grep -rn "params\.\(id\|userId\|user_id\|accountId\|orderId\)" --include="*.{js,ts,py,go,java,rb,php}"
grep -rn "request\.\(args\|params\|query\)\[" --include="*.{py,js,ts}"

# CORS
grep -rn "Access-Control-Allow-Origin\|cors(\|CORS(" --include="*.{js,ts,py,go,java,rb,php}"

# Path joining with user input
grep -rn "path\.join\|os\.path\.join\|filepath\.Join\|Path\.Combine\|File\.join" --include="*.{js,ts,py,go,java,rb,php,cs}"

# Missing auth check patterns — routes without middleware
# Compare entry points from recon with auth middleware map
```

### A02: Cryptographic Failures

**What to check:**
- Weak hash algorithms (MD5, SHA1 for passwords or signatures)
- Weak encryption (DES, 3DES, RC4, ECB mode)
- Hardcoded keys/IVs
- Missing encryption at rest for sensitive data
- Insufficient key length (<2048 RSA, <256 AES)

**Detection patterns:**
```bash
# Weak hashing
grep -rn "md5\|MD5\|sha1\|SHA1" --include="*.{py,js,ts,go,java,rb,php}" | grep -vi "test\|spec\|comment\|\.md"

# Weak encryption
grep -rn "DES\|3DES\|RC4\|ECB\|Blowfish" -i --include="*.{py,js,ts,go,java,rb,php}"

# Hardcoded keys
grep -rn "key\s*=\s*['\"][a-zA-Z0-9+/=]\{16,\}['\"]\|iv\s*=\s*['\"]" --include="*.{py,js,ts,go,java,rb,php}"

# Math.random / rand for security purposes
grep -rn "Math\.random\|rand()\|random\.random\|rand\.Intn\|Random()" --include="*.{py,js,ts,go,java,rb,php}"
```

### A03: Injection

**What to check:**
- SQL injection (string concatenation in queries)
- Command injection (user input in shell commands)
- Template injection / SSTI (user input in template rendering)
- NoSQL injection (user objects in MongoDB queries)
- LDAP injection, XPath injection, header injection

**Detection patterns:**
```bash
# SQL injection — string concat near query execution
grep -rn "execute\|query\|raw\|cursor\.\|\.sql(" --include="*.{py,js,ts,go,java,rb,php}" | grep -i "f\"\|format(\|%s\|\+\s*\|concat\|\${"

# Command injection
grep -rn "exec(\|execSync\|spawn(\|popen\|subprocess\|system(\|os\.system\|Runtime\.exec\|Process\.Start\|shell_exec\|backtick" --include="*.{py,js,ts,go,java,rb,php,cs}"

# Template injection / SSTI
grep -rn "render_template_string\|Template(\|Jinja2\|nunjucks\|handlebars\.compile\|eval(\|new Function(" --include="*.{py,js,ts,rb,php}"

# NoSQL injection
grep -rn "find(\|findOne(\|aggregate(\|updateOne(\|\$where\|\$gt\|\$ne\|\$regex" --include="*.{js,ts,py}"
```

### A04: Insecure Design

**What to check:**
- Missing rate limiting on sensitive endpoints (login, password reset, API)
- Predictable resource IDs (sequential integers for sensitive resources)
- Business logic flaws (race conditions in transactions, order manipulation)
- Missing account lockout after failed login attempts
- Lack of input validation at the design level

**Detection patterns:**
```bash
# Rate limiting
grep -rn "rate.limit\|rateLimit\|throttle\|RateLimiter\|slowDown\|limiter" -i --include="*.{py,js,ts,go,java,rb,php}"

# Sequential IDs
grep -rn "autoIncrement\|AUTO_INCREMENT\|SERIAL\|IDENTITY\|nextval" -i --include="*.{py,js,ts,go,java,rb,php,sql}"

# Race condition signals — transactions, locks
grep -rn "BEGIN\|COMMIT\|ROLLBACK\|\.lock\|mutex\|synchronized\|atomic" -i --include="*.{py,js,ts,go,java,rb,php}"
```

### A05: Security Misconfiguration

**What to check:**
- Debug mode enabled in production config
- Default credentials in config files
- Verbose error messages returned to clients
- Missing security headers (CSP, HSTS, X-Frame-Options, X-Content-Type-Options)
- Unnecessary features/ports/services enabled
- Stack traces in error responses

**Detection patterns:**
```bash
# Debug mode
grep -rn "DEBUG\s*=\s*True\|debug:\s*true\|NODE_ENV.*development\|app\.debug" -i --include="*.{py,js,ts,go,java,rb,php,yaml,yml,toml,json}"

# Default credentials
grep -rn "admin:admin\|password123\|default.*password\|changeme\|letmein" -i --include="*.{py,js,ts,go,java,rb,php,yaml,yml,toml,json,env}"

# Error handling that leaks info
grep -rn "stack\|traceback\|stackTrace\|printStackTrace\|e\.message\|err\.message" --include="*.{py,js,ts,go,java,rb,php}"

# Security headers
grep -rn "helmet\|Content-Security-Policy\|X-Frame-Options\|Strict-Transport-Security\|X-Content-Type-Options" -i --include="*.{py,js,ts,go,java,rb,php}"
```

### A06: Vulnerable and Outdated Components

**What to check:**
- Known vulnerable dependency versions
- Outdated major versions of frameworks
- Dependencies with known CVEs
- Unmaintained dependencies (no commits in 2+ years)

**Detection approach:**
```bash
# Check for lockfile age
git log -1 --format="%ai" -- package-lock.json yarn.lock pnpm-lock.yaml Gemfile.lock poetry.lock Cargo.lock go.sum

# Count dependencies
# Node
cat package.json | grep -c "\":" 2>/dev/null || true
# Python
cat requirements.txt 2>/dev/null | wc -l || cat pyproject.toml 2>/dev/null | grep -c "=" || true
```

Note: Full CVE checking requires external tools (npm audit, pip-audit, etc.). Flag the need but acknowledge this skill is manual review, not automated scanning.

### A07: Identification and Authentication Failures

**What to check:**
- Weak password policies (no length/complexity requirements)
- Session fixation (session ID not regenerated after login)
- Missing session timeout/expiration
- Credentials in URLs
- Missing multi-factor authentication for sensitive operations

**Detection patterns:**
```bash
# Password policy
grep -rn "password.*length\|min.*password\|password.*min\|validate.*password\|passwordValidator" -i --include="*.{py,js,ts,go,java,rb,php}"

# Session management
grep -rn "session\.regenerate\|session\.destroy\|maxAge\|expires\|session_lifetime\|SESSION_COOKIE_AGE\|idle.*timeout" -i --include="*.{py,js,ts,go,java,rb,php,yaml,yml,toml}"

# Remember-me tokens
grep -rn "remember.me\|rememberMe\|persistent.*session\|long.lived.*token" -i --include="*.{py,js,ts,go,java,rb,php}"
```

### A08: Software and Data Integrity Failures

**What to check:**
- Insecure deserialization (pickle, yaml.load, ObjectInputStream, unserialize)
- Missing integrity checks on downloads/updates
- CI/CD pipeline manipulation vectors
- Unsigned data used for critical decisions

**Detection patterns:**
```bash
# Insecure deserialization
grep -rn "pickle\.load\|yaml\.load\|yaml\.unsafe_load\|Marshal\.load\|ObjectInputStream\|unserialize\|JSON\.parse.*eval\|deserialize" --include="*.{py,js,ts,go,java,rb,php}"

# Safe alternatives check
grep -rn "yaml\.safe_load\|pickle\.loads.*protocol\|ObjectInputFilter\|json_decode" --include="*.{py,js,ts,go,java,rb,php}"
```

### A09: Security Logging and Monitoring Failures

**What to check:**
- Sensitive data in logs (passwords, tokens, PII)
- Missing audit logging for security events (login, failed auth, privilege changes)
- Logs that could be injected (unsanitized user input in log messages)
- Missing alerting on security events

**Detection patterns:**
```bash
# Sensitive data in logs
grep -rn "log\.\|logger\.\|console\.log\|logging\.\|print(" --include="*.{py,js,ts,go,java,rb,php}" | grep -i "password\|secret\|token\|key\|credit.card\|ssn"

# Auth event logging
grep -rn "login.*log\|auth.*log\|failed.*login\|log.*auth\|audit" -i --include="*.{py,js,ts,go,java,rb,php}"

# Log injection
grep -rn "log\.info.*\+\|logger\.info.*\+\|log\.error.*\$\{" --include="*.{py,js,ts,go,java,rb,php}"
```

### A10: Server-Side Request Forgery (SSRF)

**What to check:**
- User-controlled URLs in server-side HTTP calls
- URL validation bypass (IP representation tricks, DNS rebinding)
- Access to internal services via SSRF (metadata endpoints, internal APIs)

**Detection patterns:**
```bash
# Server-side HTTP with user input
grep -rn "requests\.get\|requests\.post\|http\.Get\|http\.Post\|fetch(\|axios\.\|urllib\|HttpClient\|WebClient\|curl_exec\|file_get_contents" --include="*.{py,js,ts,go,java,rb,php,cs}"

# URL construction from user input
grep -rn "url\s*=.*request\|url\s*=.*params\|url\s*=.*input\|url\s*=.*args" --include="*.{py,js,ts,go,java,rb,php}"
```

---

## Phase 5: Deep Dive on HIGH/CRITICAL Findings

For every finding rated HIGH or CRITICAL in Phase 4, perform this deep dive. Do NOT skip this phase.

### Full Execution Path Trace

Starting from the entry point where the vulnerability is reachable:

1. Map the exact code path from HTTP request (or other input) to the vulnerable code
2. Identify every validation/sanitization step along the path
3. Identify where each check can be bypassed (or confirm it can't)
4. Document the complete path: `entry → middleware → handler → service → vulnerable call`

### Exploit Scenario Template

For each HIGH/CRITICAL finding:

```markdown
### Finding: [title]

**OWASP Category**: [A01-A10]
**Location**: [file:line]
**Severity**: [HIGH / CRITICAL]
**Confidence**: [HIGH / MEDIUM / LOW]

**Attacker Model**:
- Who: [unauthenticated / authenticated user / admin / ...]
- Access: [what they can reach]
- Interface: [which endpoint/input]

**Exploit Steps**:
1. Attacker sends [exact request/input] to [endpoint/interface]
2. Input reaches [function] at [file:line] because [why — no validation / bypass of check]
3. At [file:line], the input causes [specific behavior — query execution / command run / file read]
4. Result: [concrete impact — data exfiltrated / code executed / access granted]

**Proof of Concept**:
```
[Exact HTTP request, CLI command, or code snippet that triggers the vulnerability]
```

**Impact**:
- [Specific, concrete impact — not "could cause issues"]
- [Data affected, scope of access, blast radius]

**Exploitability**: [EASY / MEDIUM / HARD]
- EASY: No auth required, simple request, no special conditions
- MEDIUM: Requires auth or specific state, but achievable
- HARD: Requires chained exploits, race conditions, or special access

**Recommendation**:
```[language]
// Specific code fix, not just "add validation"
```
```

### Cross-Reference with Threat Model

For each HIGH/CRITICAL finding:
- Which trust boundary does it violate?
- Which attacker profile can exploit it?
- Which STRIDE category does it fall under?
- Does exploiting this finding enable other attacks? (chaining)

---

## Language Quick Reference

Use this table for language-specific vulnerability patterns when context from earlier phases indicates the language in use.

| Language | Injection Hotspots | Crypto Pitfalls | Deserialization Risk | Path Traversal |
|----------|-------------------|-----------------|---------------------|---------------|
| **Python** | `f""` in SQL, `subprocess` with `shell=True`, `eval()`, `exec()` | `hashlib.md5()`, `random` module for secrets | `pickle.load()`, `yaml.load()` | `os.path.join()` doesn't prevent `../` from absolute paths |
| **JS/TS** | Template literals in queries, `child_process.exec()`, `eval()`, `new Function()` | `crypto.createHash('md5')`, `Math.random()` | `JSON.parse()` is safe but `eval(json)` is not, `node-serialize` | `path.join()` normalizes but check for null bytes |
| **Go** | `fmt.Sprintf` in SQL, `exec.Command` with user input | `md5.New()`, `math/rand` for security | Go stdlib JSON is safe; `gob` from untrusted sources is risky | `filepath.Clean()` then verify prefix |
| **Rust** | `format!` in SQL (use sqlx params), `Command::new` | Less common; check for `md5` crate usage | `serde` is generally safe; custom deserializers need audit | `Path::canonicalize()` then check prefix |
| **Java** | String concat in JDBC, `Runtime.exec()`, EL injection | `MessageDigest.getInstance("MD5")`, `java.util.Random` | `ObjectInputStream`, `XMLDecoder`, `SnakeYAML` | `new File(base, userInput)` — use `getCanonicalPath()` |
| **C#** | String concat in `SqlCommand`, `Process.Start()` | `MD5.Create()`, `new Random()` | `BinaryFormatter`, `XmlSerializer` with type control | `Path.Combine()` doesn't prevent `../` |
| **Ruby** | String interpolation in ActiveRecord `.where()`, `system()`, ERB injection | `Digest::MD5`, `rand()` | `Marshal.load()`, `YAML.load()` | `File.join()` then verify prefix |
| **PHP** | `$_GET` in `mysqli_query()`, `exec()`, `system()` | `md5()`, `rand()` | `unserialize()`, `simplexml_load_string()` | `realpath()` then check prefix |
| **C/C++** | `sprintf` → buffer overflow, `system()`, format strings | `MD5_Init()`, `rand()`, `srand()` | Custom parsers — check bounds | `realpath()` then check prefix, check for null bytes |

## Phase 4-5 Output Template

```markdown
## Vulnerability Findings

### Summary
| Severity | Count |
|----------|-------|
| CRITICAL | [n] |
| HIGH     | [n] |
| MEDIUM   | [n] |
| LOW      | [n] |

### Findings

#### [SEVERITY] [F-001]: [Title]
**OWASP**: [category]
**Location**: `file:line`
**Confidence**: [HIGH/MEDIUM/LOW]

**Description**: [what the vulnerability is, in specific terms]

**Exploit Scenario**: [for HIGH/CRITICAL — from Phase 5 template]

**Recommendation**:
```[language]
[specific fix]
```

---
[repeat for each finding]
```
